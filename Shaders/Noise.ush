#pragma once

#include "/Project/Random.ush"

#define myMGradientMask int3(0x8, 0x4, 0x2)
#define myMGradientScale float3(1. / 0x4, 1. / 0x2, 1. / 0x1)

uint3 Hash_Multiplexer(int Hash, uint3 pos)
{
    uint4 p = uint4(pos.xyz, pos.x ^ pos.y ^ pos.z);

    if (Hash == 0) {            // bbs
        return bbs(p.x);
    } else if (Hash == 1) {     // bbs_linear2
        return bbs(seed(p.xy));
    } else if (Hash == 2) {     // bbs_linear3
        return bbs(seed(p.xyz));
    } else if (Hash == 3) {     // bbs_linear4
        return bbs(seed(p));
    } else if (Hash == 4) {     // bbs_nested2
        return bbs(bbs(p.x) + p.y);
    } else if (Hash == 5) {     // bbs_nested3
        return bbs(bbs(bbs(p.x) + p.y) + p.z);
    } else if (Hash == 6) {     // bbs_nested4
        return bbs(bbs(bbs(bbs(p.x) + p.y) + p.z) + p.w);
    } else if (Hash == 7) {     // city
        return city(p.x);
    } else if (Hash == 8) {     // city_linear2
        return city(seed(p.xy));
    } else if (Hash == 9) {     // city_linear3
        return city(seed(p.xyz));
    } else if (Hash == 10) {     // city_linear4
        return city(seed(p));
    } else if (Hash == 11) {     // city_multibyte2
        return city(p.xy);
    } else if (Hash == 12) {     // city_multibyte3
        return city(p.xyz);
    } else if (Hash == 13) {     // city_multibyte4
        return city(p);
    } else if (Hash == 14) {     // city_nested2
        return city(city(p.x) + p.y);
    } else if (Hash == 15) {     // city_nested3
        return city(city(city(p.x) + p.y) + p.z);
    } else if (Hash == 16) {     // city_nested4
        return city(city(city(city(p.x) + p.y) + p.z) + p.w);
    } else if (Hash == 17) {     // esgtsa
        return esgtsa(p.x);
    } else if (Hash == 18) {     // esgtsa_linear2
        return esgtsa(seed(p.xy));
    } else if (Hash == 19) {     // esgtsa_linear3
        return esgtsa(seed(p.xyz));
    } else if (Hash == 20) {     // esgtsa_linear4
        return esgtsa(seed(p));
    } else if (Hash == 21) {     // esgtsa_nested2
        return esgtsa(esgtsa(p.x) + p.y);
    } else if (Hash == 22) {     // esgtsa_nested3
        return esgtsa(esgtsa(esgtsa(p.x) + p.y) + p.z);
    } else if (Hash == 23) {     // esgtsa_nested4
        return esgtsa(esgtsa(esgtsa(esgtsa(p.x) + p.y) + p.z) + p.w);
    } else if (Hash == 24) {     // fast
        return RandFast(p.xy);
    } else if (Hash == 25) {     // hashwithoutsine11
        return hashwithoutsine11(p.x);
    } else if (Hash == 26) {     // hashwithoutsine12
        return uint3(hashwithoutsine12(p.x).xy, 0u);
    } else if (Hash == 27) {     // hashwithoutsine13
        return hashwithoutsine13(p.x);
    } else if (Hash == 28) {     // hashwithoutsine21
        return hashwithoutsine21(p.xy);
    } else if (Hash == 29) {     // hashwithoutsine22
        return uint3(hashwithoutsine(p.xy), 0u);
    } else if (Hash == 30) {     // hashwithoutsine23
        return hashwithoutsine23(p.xyz);
    } else if (Hash == 31) {     // hashwithoutsine31
        return hashwithoutsine31(p.xyz);
    } else if (Hash == 32) {     // hashwithoutsine32
        return uint3(hashwithoutsine32(p.xyz),0);
    } else if (Hash == 33) {     // hashwithoutsine33
        return hashwithoutsine33(p.xyz);
    } else if (Hash == 34) {     // hashwithoutsine41
        return hashwithoutsine41(p);
    } else if (Hash == 35) {     // hashwithoutsine42
        return uint3(hashwithoutsine42(p),0);
    } else if (Hash == 36) {     // hashwithoutsine43
        return hashwithoutsine33(p.xyz);
    } else if (Hash == 37) {     // hashwithoutsine44
        return hashwithoutsine44(p).xyz;
    } else {
        return 0;
    }

    /*

    } else if (Hash == 38) {     // hybridtaus
        return hybridtaus(p);
    } else if (Hash == 39) {     // ign
        return uint3(ign(float2(p.xy) / float(0xffffffffu)) * 0xffffffffu);
    } else if (Hash == 40) {     // iqint1
        return uint3(iqint1(p.x));
    } else if (Hash == 41) {     // iqint1_linear2
        return uint3(iqint1(seed(p.xy)));
    } else if (Hash == 42) {     // iqint1_linear3
        return uint3(iqint1(seed(p.xyz)));
    } else if (Hash == 43) {     // iqint1_linear4
        return uint3(iqint1(seed(p)));
    } else if (Hash == 44) {     // iqint1_nested2
        return uint3(iqint1(iqint1(p.x) + p.y));
    } else if (Hash == 45) {     // iqint1_nested3
        return uint3(iqint1(iqint1(iqint1(p.x) + p.y) + p.z));
    } else if (Hash == 46) {     // iqint1_nested4
        return uint3(iqint1(iqint1(iqint1(iqint1(p.x) + p.y) + p.z) + p.w));
    } else if (Hash == 47) {     // iqint2
        return iqint2(p.xyz);
    } else if (Hash == 48) {     // iqint3
        return uint3(iqint3(p.xy));
    } else if (Hash == 49) {     // jkiss32
        return uint3(jkiss32(p.xy));
    } else if (Hash == 50) {     // lcg
        return uint3(lcg(p.x));
    } else if (Hash == 51) {     // lcg_linear2
        return uint3(lcg(seed(p.xy)));
    } else if (Hash == 52) {     // lcg_linear3
        return uint3(lcg(seed(p.xyz)));
    } else if (Hash == 53) {     // lcg_linear4
        return uint3(lcg(seed(p)));
    } else if (Hash == 54) {     // lcg_nested2
        return uint3(lcg(lcg(p.x) + p.y));
    } else if (Hash == 55) {     // lcg_nested3
        return uint3(lcg(lcg(lcg(p.x) + p.y) + p.z));
    } else if (Hash == 56) {     // lcg_nested4
        return uint3(lcg(lcg(lcg(lcg(p.x) + p.y) + p.z) + p.w));
    } else if (Hash == 57) {     // md5_1
        return md5(p.x).xyz;
    } else if (Hash == 58) {     // md5_2
        return md5(p.xy).xyz;
    } else if (Hash == 59) {     // md5_3
        return md5(p.xyz).xyz;
    } else if (Hash == 60) {     // md5_4
        return md5(p).xyz;
    } else if (Hash == 61) {     // murmur3
        return uint3(murmur3(p.x));
    } else if (Hash == 62) {     // murmur3_linear2
        return uint3(murmur3(seed(p.xy)));
    } else if (Hash == 63) {     // murmur3_linear3
        return uint3(murmur3(seed(p.xyz)));
    } else if (Hash == 64) {     // murmur3_linear4
        return uint3(murmur3(seed(p)));
    } else if (Hash == 65) {     // murmur3_multibyte2
        return uint3(murmur3(p.xy));
    } else if (Hash == 66) {     // murmur3_multibyte3
        return uint3(murmur3(p.xyz));
    } else if (Hash == 67) {     // murmur3_multibyte4
        return uint3(murmur3(p));
    } else if (Hash == 68) {     // murmur3_nested2
        return uint3(murmur3(murmur3(p.x) + p.y));
    } else if (Hash == 69) {     // murmur3_nested3
        return uint3(murmur3(murmur3(murmur3(p.x) + p.y) + p.z));
    } else if (Hash == 70) {     // murmur3_nested4
        return uint3(murmur3(murmur3(murmur3(murmur3(p.x) + p.y) + p.z) + p.w));
    } else if (Hash == 71) {     // pcg
        return uint3(pcg(p.x));
    } else if (Hash == 72) {     // pcg2d
        return uint3(pcg2d(p.xy),0);
    } else if (Hash == 73) {     // pcg3d
        return pcg3d(p.xyz);
    } else if (Hash == 74) {     // pcg3d16
        return pcg3d(p.xyz);
    } else if (Hash == 75) {     // pcg4d
        return pcg4d(p.xyzw);
    } else if (Hash == 76) {     // pcg_linear2
    } else if (Hash == 77) {     // pcg_linear3
    } else if (Hash == 78) {     // pcg_linear4
    } else if (Hash == 79) {     // pcg_nested2
    } else if (Hash == 80) {     // pcg_nested3
    } else if (Hash == 81) {     // pcg_nested4
    } else if (Hash == 82) {     // pseudo
    } else if (Hash == 83) {     // ranlim32
    } else if (Hash == 84) {     // ranlim32_linear2
    } else if (Hash == 85) {     // ranlim32_linear3
    } else if (Hash == 86) {     // ranlim32_linear4
    } else if (Hash == 87) {     // ranlim32_nested2
    } else if (Hash == 88) {     // ranlim32_nested3
    } else if (Hash == 89) {     // ranlim32_nested4
    } else if (Hash == 90) {     // superfast
    } else if (Hash == 91) {     // superfast_linear2
    } else if (Hash == 92) {     // superfast_linear3
    } else if (Hash == 93) {     // superfast_linear4
    } else if (Hash == 94) {     // superfast_multibyte2
    } else if (Hash == 95) {     // superfast_multibyte3
    } else if (Hash == 96) {     // superfast_multibyte4
    } else if (Hash == 97) {     // superfast_nested2
    } else if (Hash == 98) {     // superfast_nested3
    } else if (Hash == 99) {     // superfast_nested4
    } else if (Hash == 100) {     // tea2
    } else if (Hash == 101) {     // tea3
    } else if (Hash == 102) {     // tea4
    } else if (Hash == 103) {     // tea5
    } else if (Hash == 104) {     // tea6
    } else if (Hash == 105) {     // trig
    } else if (Hash == 106) {     // wang
    } else if (Hash == 107) {     // wang_linear2
    } else if (Hash == 108) {     // wang_linear3
    } else if (Hash == 109) {     // wang_linear4
    } else if (Hash == 110) {     // wang_nested2
    } else if (Hash == 111) {     // wang_nested3
    } else if (Hash == 112) {     // wang_nested4
    } else if (Hash == 113) {     // xorshift128
    } else if (Hash == 114) {     // xorshift32
    } else if (Hash == 115) {     // xorshift32_linear2
    } else if (Hash == 116) {     // xorshift32_linear3
    } else if (Hash == 117) {     // xorshift32_linear4
    } else if (Hash == 118) {     // xorshift32_nested2
    } else if (Hash == 119) {     // xorshift32_nested3
    } else if (Hash == 120) {     // xorshift32_nested4
    } else if (Hash == 121) {     // xxhash32
    } else if (Hash == 122) {     // xxhash32_linear2
    } else if (Hash == 123) {     // xxhash32_linear3
    } else if (Hash == 124) {     // xxhash32_linear4
    } else if (Hash == 125) {     // xxhash32_multibyte2
    } else if (Hash == 126) {     // xxhash32_multibyte3
    } else if (Hash == 127) {     // xxhash32_multibyte4
    } else if (Hash == 128) {     // xxhash32_nested2
    } else if (Hash == 129) {     // xxhash32_nested3
    } else if (Hash == 130) {     // xxhash32_nested4
    }*/

    /*
    switch(Hash)
    {
        case 0:
            return bbs(bbs(bbs(pos.x) + pos.y) + pos.z);
        case 1:
            return city(city(city(pos.x) + pos.y) + pos.z);
        case 2:
            return esgtsa(esgtsa(esgtsa(pos.x) + pos.y) + pos.z);
        case 3:
            return RandFast(pos.xy) * 0xffffffffu;
        case 4:
            return hashwithoutsine13(pos) * 0xffffffffu;
        case 5:
            return hybridtaus(uint4(pos,0));
        case 6:
            return ign(pos.xy) * 0xffffffffu;
        case 7:
            return iqint1(iqint1(iqint1(pos.x) + pos.y) + pos.z);
        case 8:
            return iqint2(pos);
        case 9:
            return iqint3(pos.xy);
        case 10:
            return jkiss32(pos.xy);
        case 11:
            return lcg(lcg(lcg(pos.x) + pos.y) + pos.z);
        case 12:
            return murmur3(pos.xy);
        case 13:
            return uint3(pcg2d(pos.xy),0);
        case 14:
            return pcg3d(pos);
        case 15:
            return pcg3d16(pos);
        case 16:
            return pcg4d(uint4(pos,0)).xyz;
        case 17:
            return PseudoRandom(pos.xy);
        case 18:
            return ranlim32(ranlim32(ranlim32(pos.x) + pos.y) + pos.z);
        case 19:
            return superfast(superfast(superfast(pos.x) + pos.y) + pos.z);
        case 20:
            return uint3(tea(2,pos.xy), 0);
        case 21:
            return uint3(tea(3,pos.xy), 0);
        case 22:
            return uint3(tea(4,pos.xy), 0);
        case 23:
            return uint3(tea(5,pos.xy), 0);
        case 24:
            return uint3(tea(6,pos.xy), 0);
        case 25:
            return trig(pos.xy);
        case 26:
            return wang(wang(wang(pos.x) + pos.y) + pos.z);
        case 27:
            return xorshift128(uint4(pos,0));
        case 28:
            return xorshift32(xorshift32(xorshift32(pos.x) + pos.y) + pos.z);
        case 29:
            return xxhash32(pos);
        default:
            return 0;
    }
    return 0;
    */
}

// 3D jitter offset within a voronoi noise cell
// @param pos - integer lattice corner
// @return random offsets vector
float3 myVoronoiCornerSample(float3 pos, int Quality, int Hash)
{
    // random values in [-0.5, 0.5]
    //float3 noise = float3(Rand3DPCG16(int3(pos))) / 0xffff - 0.5;
    float3 noise = float3(Hash_Multiplexer(Hash,int3(pos)) & 0xffffu) / 0xffff - 0.5;

    // quality level 1 or 2: searches a 2x2x2 neighborhood with points distributed on a sphere
    // scale factor to guarantee jittered points will be found within a 2x2x2 search
    if (Quality <= 2)
    {
        return normalize(noise) * 0.2588;
    }

    // quality level 3: searches a 3x3x3 neighborhood with points distributed on a sphere
    // scale factor to guarantee jittered points will be found within a 3x3x3 search
    if (Quality == 3)
    {
        return normalize(noise) * 0.3090;
    }

    // quality level 4: jitter to anywhere in the cell, needs 4x4x4 search
    return noise;
}

// 220 instruction Worley noise
float4 myVoronoiNoise3D_ALU(float3 v, int Quality, bool bTiling, float RepeatSize, bool bDistanceOnly, int Hash)
{
    float3 fv = frac(v),  fv2 = frac(v + 0.5);
    float3 iv = floor(v), iv2 = floor(v + 0.5);

    // with initial minimum distance = infinity (or at least bigger than 4), first min is optimized away
    float4 mindist = float4(0,0,0,100);
    float3 p, offset;

    // quality level 3: do a 3x3x3 search
    if (Quality == 3)
    {
        UNROLL for (offset.x = -1; offset.x <= 1; ++offset.x)
        {
            UNROLL for (offset.y = -1; offset.y <= 1; ++offset.y)
            {
                UNROLL for (offset.z = -1; offset.z <= 1; ++offset.z)
                {
                    p = offset + myVoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize), Quality, Hash);
                    mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
                }
            }
        }
    }

    // everybody else searches a base 2x2x2 neighborhood
    else
    {
        UNROLL for (offset.x = 0; offset.x <= 1; ++offset.x)
        {
            UNROLL for (offset.y = 0; offset.y <= 1; ++offset.y)
            {
                UNROLL for (offset.z = 0; offset.z <= 1; ++offset.z)
                {
                    p = offset + myVoronoiCornerSample(NoiseTileWrap(iv + offset, bTiling, RepeatSize), Quality, Hash);
                    mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);

                    // quality level 2, do extra set of points, offset by half a cell
                    if (Quality == 2)
                    {
                        // 467 is just an offset to a different area in the random number field to avoid similar neighbor artifacts
                        p = offset + myVoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize) + 467, Quality, Hash);
                        mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
                    }
                }
            }
        }
    }

    // quality level 4: add extra sets of four cells in each direction
    if (Quality >= 4)
    {
        UNROLL for (offset.x = -1; offset.x <= 2; offset.x += 3)
        {
            UNROLL for (offset.y = 0; offset.y <= 1; ++offset.y)
            {
                UNROLL for (offset.z = 0; offset.z <= 1; ++offset.z)
                {
                    // along x axis
                    p = offset.xyz + myVoronoiCornerSample(NoiseTileWrap(iv + offset.xyz, bTiling, RepeatSize), Quality, Hash);
                    mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);

                    // along y axis
                    p = offset.yzx + myVoronoiCornerSample(NoiseTileWrap(iv + offset.yzx, bTiling, RepeatSize), Quality, Hash);
                    mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);

                    // along z axis
                    p = offset.zxy + myVoronoiCornerSample(NoiseTileWrap(iv + offset.zxy, bTiling, RepeatSize), Quality, Hash);
                    mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
                }
            }
        }
    }

    // transform squared distance to real distance
    return float4(mindist.xyz, sqrt(mindist.w));
}

// Simplex noise and its Jacobian derivative
// @param v = 3D noise argument
// @param bTiling = whether to repeat noise pattern
// @param RepeatSize = integer units before tiling in each dimension, must be a multiple of 3
// @return float3x3 Jacobian in J[*].xyz, vector noise in J[*].w
//     J[0].w, J[1].w, J[2].w is a Perlin-style simplex noise with vector output, e.g. (Nx, Ny, Nz)
//     J[i].x is X derivative of the i'th component of the noise so J[2].x is dNz/dx
// You can use this to compute the noise, gradient, curl, or divergence:
//   float3x4 J = JacobianSimplex_ALU(...);
//   float3 VNoise = float3(J[0].w, J[1].w, J[2].w);	// 3D noise
//   float3 Grad = J[0].xyz;							// gradient of J[0].w
//   float3 Curl = float3(J[1][2]-J[2][1], J[2][0]-J[0][2], J[0][1]-J[1][2]);
//   float Div = J[0][0]+J[1][1]+J[2][2];
// All of these are confirmed to compile out all unneeded terms.
// So Grad of X doesn't compute Y or Z components, and VNoise doesn't do any of the derivative computation.
float3x4 myJacobianSimplex_ALU(float3 v, bool bTiling, float RepeatSize, int Hash)
{
	// corners of tetrahedron
	float4x3 T = SimplexCorners(v);
	uint3 rand;
	float4x3 gvec[3], fv;
	float3x4 grad;

	// processing of tetrahedral vertices, unrolled
	// to compute gradient at each corner
	fv[0] = v - T[0];
	rand = Hash_Multiplexer(Hash,int3(floor(NoiseTileWrap(6 * T[0] + 0.5, bTiling, RepeatSize))));
	gvec[0][0] = float3(rand.xxx & myMGradientMask) * myMGradientScale - 1;
	gvec[1][0] = float3(rand.yyy & myMGradientMask) * myMGradientScale - 1;
	gvec[2][0] = float3(rand.zzz & myMGradientMask) * myMGradientScale - 1;
	grad[0][0] = dot(gvec[0][0], fv[0]);
	grad[1][0] = dot(gvec[1][0], fv[0]);
	grad[2][0] = dot(gvec[2][0], fv[0]);

	fv[1] = v - T[1];
	rand = Hash_Multiplexer(Hash,int3(floor(NoiseTileWrap(6 * T[1] + 0.5, bTiling, RepeatSize))));
	gvec[0][1] = float3(rand.xxx & myMGradientMask) * myMGradientScale - 1;
	gvec[1][1] = float3(rand.yyy & myMGradientMask) * myMGradientScale - 1;
	gvec[2][1] = float3(rand.zzz & myMGradientMask) * myMGradientScale - 1;
	grad[0][1] = dot(gvec[0][1], fv[1]);
	grad[1][1] = dot(gvec[1][1], fv[1]);
	grad[2][1] = dot(gvec[2][1], fv[1]);

	fv[2] = v - T[2];
	rand = Hash_Multiplexer(Hash,int3(floor(NoiseTileWrap(6 * T[2] + 0.5, bTiling, RepeatSize))));
	gvec[0][2] = float3(rand.xxx & myMGradientMask) * myMGradientScale - 1;
	gvec[1][2] = float3(rand.yyy & myMGradientMask) * myMGradientScale - 1;
	gvec[2][2] = float3(rand.zzz & myMGradientMask) * myMGradientScale - 1;
	grad[0][2] = dot(gvec[0][2], fv[2]);
	grad[1][2] = dot(gvec[1][2], fv[2]);
	grad[2][2] = dot(gvec[2][2], fv[2]);

	fv[3] = v - T[3];
	rand = Hash_Multiplexer(Hash,int3(floor(NoiseTileWrap(6 * T[3] + 0.5, bTiling, RepeatSize))));
	gvec[0][3] = float3(rand.xxx & myMGradientMask) * myMGradientScale - 1;
	gvec[1][3] = float3(rand.yyy & myMGradientMask) * myMGradientScale - 1;
	gvec[2][3] = float3(rand.zzz & myMGradientMask) * myMGradientScale - 1;
	grad[0][3] = dot(gvec[0][3], fv[3]);
	grad[1][3] = dot(gvec[1][3], fv[3]);
	grad[2][3] = dot(gvec[2][3], fv[3]);

	// blend gradients
	float4 sv = SimplexSmooth(fv);
	float3x4 ds = SimplexDSmooth(fv);

	float3x4 jacobian;
	jacobian[0] = float4(mul(sv, gvec[0]) + mul(ds, grad[0]), dot(sv, grad[0]));
	jacobian[1] = float4(mul(sv, gvec[1]) + mul(ds, grad[1]), dot(sv, grad[1]));
	jacobian[2] = float4(mul(sv, gvec[2]) + mul(ds, grad[2]), dot(sv, grad[2]));

	return jacobian;
}



// Material node for noise functions returning a vector value
// @param LevelScale usually 2 but higher values allow efficient use of few levels
// @return in user defined range (OutputMin..OutputMax)
MaterialFloat4 myMaterialExpressionVectorNoise(MaterialFloat3 Position, int Quality, int Function, bool bTiling, float TileSize, int Hash)
{
	float4 result = float4(0,0,0,1);
	float3x4 Jacobian = myJacobianSimplex_ALU(Position, bTiling, TileSize, Hash);	// compiled out if not used

	// verified, HLSL compiled out the switch if Function is a constant
	switch (Function)
	{
	case 0:	// Cellnoise
		result.xyz = float3(Hash_Multiplexer(Hash,(int3(floor(NoiseTileWrap(Position, bTiling, TileSize)))))) / 0xffff;
		break;
	case 1: // Color noise
		result.xyz = float3(Jacobian[0].w, Jacobian[1].w, Jacobian[2].w);
		break;
	case 2: // Gradient
		result = Jacobian[0];
		break;
	case 3: // Curl
		result.xyz = float3(Jacobian[2][1] - Jacobian[1][2], Jacobian[0][2] - Jacobian[2][0], Jacobian[1][0] - Jacobian[0][1]);
		break;
	default: // Voronoi
		result = myVoronoiNoise3D_ALU(Position, Quality, bTiling, TileSize, false, Hash);
		break;
	}
	return result;
}


float myNoise3D_Multiplexer(int Function, float3 Position, int Quality, bool bTiling, uint RepeatSize, int Hash)
{
    // verified, HLSL compiled out the switch if Function is a constant
    switch(Function)
    {
        case 0:
            return SimplexNoise3D_TEX(Position);
        case 1:
            return GradientNoise3D_TEX(Position, bTiling, RepeatSize);
        case 2:
            return FastGradientPerlinNoise3D_TEX(Position);
        case 3:
            return GradientNoise3D_ALU(Position, bTiling, RepeatSize);
        case 4:
            return ValueNoise3D_ALU(Position, bTiling, RepeatSize);
        default:
            return myVoronoiNoise3D_ALU(Position, Quality, bTiling, RepeatSize, true, Hash).w * 2. - 1.;
    }
    return 0;
}

// @param LevelScale usually 2 but higher values allow efficient use of few levels
// @return in user defined range (OutputMin..OutputMax)
MaterialFloat myMaterialExpressionNoise(float3 Position, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize, int Hash)
{
    Position *= Scale;
    FilterWidth *= Scale;

    float Out = 0.0f;
    float OutScale = 1.0f;
    float InvLevelScale = 1.0f / LevelScale;

    LOOP for(uint i = 0; i < Levels; ++i)
    {
        // fade out noise level that are too high frequent (not done through dynamic branching as it usually requires gradient instructions)
        OutScale *= saturate(1.0 - FilterWidth);

        if(bTurbulence)
        {
            Out += abs(myNoise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize, Hash)) * OutScale;
        }
        else
        {
            Out += myNoise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize, Hash) * OutScale;
        }

        Position *= LevelScale;
        RepeatSize *= LevelScale;
        OutScale *= InvLevelScale;
        FilterWidth *= LevelScale;
    }

    if(!bTurbulence)
    {
        // bring -1..1 to 0..1 range
        Out = Out * 0.5f + 0.5f;
    }

    // Out is in 0..1 range
    return lerp(OutputMin, OutputMax, Out);
}
