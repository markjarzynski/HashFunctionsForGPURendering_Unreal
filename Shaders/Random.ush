// do more for timing tests

// Helper Functions
uint rotl(uint x, uint r)
{
	return (x << r) | (x >> (32u - r));
}

uint rotr(uint x, uint r)
{
	return (x >> r) | (x << (32u - r));
}

uint fmix(uint h)
{
  h ^= h >> 16;
  h *= 0x85ebca6bu;
  h ^= h >> 13;
  h *= 0xc2b2ae35u;
  h ^= h >> 16;
  return h;
}

uint mur(uint a, uint h) {
  // Helper from Murmur3 for combining two 32-bit values.
  uint c1 = 0xcc9e2d51u, c2 = 0x1b873593u;
  a *= c1;
  a = rotr(a, 17u);
  a *= c2;
  h ^= a;
  h = rotr(h, 19u);
  return h * 5u + 0xe6546b64u;
}

// convert 2D seed to 1D
// 2 imad
uint seed(uint2 p) {
    return 19u * p.x + 47u * p.y + 101u;
}

// Hashes

// BBS-inspired hash
//  - Olano, Modified Noise for Evaluation on Graphics Hardware, GH 2005
// seed + 2 iops + 3 imod
uint bbs(uint v) {
    v = v % 65521u;
    v = (v * v) % 65521u;
    v = (v * v) % 65521u;
    return v;
}

// CityHash32, adapted from Hash32Len0to4 in https://github.com/google/cityhash
uint city(uint s)
{
    uint c1 = 0xcc9e2d51u, c2 = 0x1b873593u;
    uint len = 4u;
	uint b = 0u;
    uint c = 9u;

    for (uint i = 0u; i < len; i++) {
    	uint v = (s >> (i * 8u)) & 0xffu;
        b = b * c1 + v;
        c ^= b;
    }

    return fmix(mur(b, mur(len, c)));
}

// Interleaved Gradient Noise
//  - Jimenez, Next Generation Post Processing in Call of Duty: Advanced Warfare
//    Advances in Real-time Rendering, SIGGRAPH 2014
// 4 flops + 1 2 frac
float ign(float2 v) {
    float3 magic = float3(0.06711056f, 0.00583715f, 52.9829189f);
    return frac(magic.z * frac(dot(v, magic.xy)));
}

// Integer Hash - I
// - Inigo Quilez, Integer Hash - I, 2017
//   https://www.shadertoy.com/view/llGSzw
uint iqint1(uint n)
{
    // integer hash copied from Hugo Elias
	n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;

    return n;
}

// Integer Hash - II
// - Inigo Quilez, Integer Hash - II, 2017
//   https://www.shadertoy.com/view/XlXcW4
uint3 iqint2(uint3 x)
{
    const uint k = 1103515245u;

    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;
    x = ((x>>8U)^x.yzx)*k;

    return x;
}

// Integer Hash - III
// - Inigo Quilez, Integer Hash - III, 2017
//   https://www.shadertoy.com/view/4tXyWN
uint iqint3(uint2 x)
{
    uint2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );
    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );

    return n;
}

uint jkiss32(uint2 p)
{
    uint x=p.x;//123456789;
    uint y=p.y;//234567891;

    uint z=345678912,w=456789123,c=0;
    int t;
    y ^= (y<<5); y ^= (y>>7); y ^= (y<<22);
    t = z+w+c; z = w; c = t < 0; w = t&2147483647;
    x += 1411392427;
    return x + y + w;
}

// linear congruential generator
// seed + 1 imad
uint lcg(uint2 p) {
    return seed(p) * 1664525u + 1013904223u;
}

// Adapted from MurmurHas3_x86_32 from https://github.com/aappleby/smhasher
uint murmur3(uint2 seed)
{
    uint c1 = 0xcc9e2d51u, c2 = 0x1b873593u;
    uint h = seed.x;
    uint k = seed.y;

    k *= c1;
    k = uint(rotl(k,15u));
    k *= c2;

    h ^= k;

    h = rotl(h,13u);
    h = h*5u+0xe6546b64u;

    h ^= h >> 16u;
    h *= 0x85ebca6bu;
    h ^= h >> 13u;
    h *= 0xc2b2ae35u;
    h ^= h >> 16u;

    return h;
}

// 9 imad (+ 6 iops with final shuffle)
uint3 pcg3d(uint3 v) {

    v = v * 1664525u + 1013904223u;

    v.x += v.y*v.z;
    v.y += v.z*v.x;
    v.z += v.x*v.y;

    v ^= v >> 16u;

    v.x += v.y*v.z;
    v.y += v.z*v.x;
    v.z += v.x*v.y;

    return v;
}

// 9 imad (+ 12 iops with final shuffle), can be done with 16 bit ints
uint3 pcg3d16(uint3 v) {
    v = v * 12829u + 47989u;
    v.x += v.y*v.z;
    v.y += v.z*v.x;
    v.z += v.x*v.y;

    v.x += v.y*v.z;
    v.y += v.z*v.x;
    v.z += v.x*v.y;
    return v;
}

// Numerical Recipies 3rd Edition
uint ranlim32(uint2 p){
    uint j, u, v, w1, w2, x, y;

    j = seed(p);

    v = 2244614371U;
    w1 = 521288629U;
    w2 = 362436069U;

    u = j ^ v;

    u = u * 2891336453U + 1640531513U;
    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;
    w1 = 33378 * (w1 & 0xffff) + (w1 >> 16);
    w2 = 57225 * (w2 & 0xffff) + (w2 >> 16);

    v = u;

    u = u * 2891336453U + 1640531513U;
    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;
    w1 = 33378 * (w1 & 0xffff) + (w1 >> 16);
    w2 = 57225 * (w2 & 0xffff) + (w2 >> 16);

    x = u ^ (u << 9); x ^= x >> 17; x ^= x << 6;
    y = w1 ^ (w1 << 17); y ^= y >> 15; y ^= y << 5;

    return (x + v) ^ (y + w2);
}

// Schechter and Bridson hash https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint esgtsa(uint s) {
    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;
    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;
    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;
    return s;
}

// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html
uint superfast(uint data)
{
	uint hash = 4u, tmp;

    hash += data & 0xffffu;
    tmp = (((data >> 16) & 0xffffu) << 11) ^ hash;
    hash = (hash << 16) ^ tmp;
    hash += hash >> 11;

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}

// Tiny Encryption Algorithm
//  - Zafar et al., GPU random numbers via the tiny encryption algorithm, HPG 2010
// 13 iops per iteration
// 26 for 2 (barely passable for noise)
// 78 for 6
uint2 tea(uint tea, uint3 p) {
    uint s = p.z;

    for( uint i = 0; i < tea; i++) {
        s += 0x9E3779B9u;
        p.x += (p.y<<4u)^(p.y+s)^(p.y>>5u);
        p.y += (p.x<<4u)^(p.x+s)^(p.x>>5u);
    }
    return p.xy;
}

// common GLSL hash
//  - Rey, On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1,
//    22nd European Meeting of Statisticians and the 7th Vilnius Conference on
//    Probability Theory and Mathematical Statistics, August 1998
// 4 flop, 1 fsin, 1 frac
/*
uint2 trig(uint2 p) {
    return uint2(float(0xffffff)*frac(43757.5453*sin(dot(float2(p),float2(12.9898,78.233)))));
}
*/
float trig(float2 p) {
    return frac(43757.5453*sin(dot(p, float2(12.9898,78.233))));
}

// Wang hash, described on http://burtleburtle.net/bob/hash/integer.html
// original page by Thomas Wang 404
// seed + 9 iops
uint wang(uint v) {
    v = (v ^ 61u) ^ (v >> 16u);
    v *= 9u;
    v ^= v >> 4u;
    v *= 0x27d4eb2du;
    v ^= v >> 15u;
    return v;
}

// 128-bit xorshift
//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003
// 7 ALU ops per round
#define XORSHIFT128 1
uint xorshift128(uint2 p) {
    uint4 v = uint4(p, p);
    for(int i=0; i < XORSHIFT128; ++i) {
        v.w ^= v.w << 11u;
        v.w ^= v.w >> 8u;
        v = v.wxyz;
        v.x ^= v.y;
        v.x ^= v.y >> 19u;
    }
    return v.x;
}

// 32-bit xorshift
//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003
// seed + 6 iops
uint xorshift32(uint v) {
    v ^= v << 13u;
    v ^= v >> 17u;
    v ^= v << 5u;
    return v;
}

// Hash without Sine, https://www.shadertoy.com/view/4djSRW
float3 hashwithoutsine(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+19.19);
    return frac((p3.xxy+p3.yzz)*p3.zyx);
}

uint taus(uint z, int s1, int s2, int s3, uint m)
{
	uint b = (((z << s1) ^ z) >> s2);
    return (((z & m) << s3) ^ b);
}

// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch37.html
uint hybridtaus(uint4 z)
{
    for (int i = 0; i < 1; i++) {
        z.x = taus(z.x, 13, 19, 12, 4294967294u);
        z.y = taus(z.y, 2, 25, 4, 4294967288u);
        z.z = taus(z.z, 3, 11, 17, 4294967280u);
        z.w = z.w * 1664525u + 1013904223u;
    }

    return z.x ^ z.y ^ z.z ^ z.w;
}

uint2 pcg2d(uint2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    return v;
}

uint4 pcg4d(uint4 v)
{
	v = v * 1664525u + 1013904223u;

    v.x += v.y*v.w;
    v.y += v.z*v.x;
    v.z += v.x*v.y;
    v.w += v.y*v.z;

    v.x += v.y*v.w;
    v.y += v.z*v.x;
    v.z += v.x*v.y;
    v.w += v.y*v.z;

    v = v ^ (v>>16u);

    return v;
}

uint3 hash3mul(uint u)
{
    uint x = esgtsa(u);
    uint y = x * 16807u;
    uint z = y * 48271u;

    return uint3(x, y, z);// n * 69621u);
}

uint3 hash3add(uint u)
{
    uint x = esgtsa(u);
    uint y = esgtsa(x + 16807u);
    uint z = esgtsa(y + 48271u);

    return uint3(x, y, z);
}
