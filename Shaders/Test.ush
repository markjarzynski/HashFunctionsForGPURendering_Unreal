float test_bbs( float2 p ) {
    uint2 v = uint2(p * UINT16_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = bbs(s);
    }

    return s / UINT16_MAX;
}

float test_city( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = city(s);
    }

    return s / UINT_MAX;
}

float test_RandBBSfloat ( float2 p ) {

    for (int i = 0; i < ITERATIONS; i++) {
        p = RandBBSfloat(seed(p)).xx;
    }

    return p.x;
}

float test_RandFast ( float2 p ) {
    for (int i = 0; i < ITERATIONS; i++) {
        p = RandFast(p).xx;
    }

    return p.x;
}

float3 test_hashwithoutsine( float2 p ) {
    float3 v = float3(p, 0.0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = hashwithoutsine(v.xy);
    }

    return v;
}

float test_hybridtaus( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = hybridtaus(v).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_ign( float2 v ) {
    for (int i = 0; i < ITERATIONS; i++) {
        v = ign(v).xx;
    }

    return v.x;
}

float test_iqint1( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = iqint1(s);
    }

    return s / UINT_MAX;
}

float3 test_iqint2( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint2(v);
    }

    return v / UINT_MAX;
}

float test_iqint3( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint3(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_jkiss32( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = jkiss32(v).xx;
    }

    return v.y / UINT_MAX;
}

float test_lcg( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = lcg(s);
    }

    return s / UINT_MAX;
}

float test_murmur3( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = murmur3(v).xx;
    }

    return v.x / UINT_MAX;
}

float3 test_pcg3d( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d(v);
    }

    return v / UINT_MAX;
}

float3 test_pcg3d16( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d16(v);
    }

    return v / UINT16_MAX;
}

float test_pcg2d( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg2d(v);
    }

    return v.y / UINT_MAX;
}

float3 test_pcg4d( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg4d(v);
    }

    return v.yzw / UINT_MAX;
}

float test_PseudoRandom( float2 v ) {
    for (int i = 0; i < ITERATIONS; i++) {
        v = PseudoRandom(v).xx;
    }

    return v.y;
}

float3 test_Rand3DPCG16( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = Rand3DPCG16(v);
    }

    return v / UINT16_MAX;
}

float3 test_Rand3DPCG32( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = Rand3DPCG32(v);
    }

    return v / UINT_MAX;
}

float3 test_Rand4DPCG32( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = Rand4DPCG32(v);
    }

    return v.yzw / UINT_MAX;
}

float test_ranlim32( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = ranlim32(s);
    }

    return s / UINT_MAX;
}

float test_esgtsa( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = esgtsa(s);
    }

    return s / UINT_MAX;
}

float test_superfast( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = superfast(s);
    }

    return s / UINT_MAX;
}

float test_tea( uint t, float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = tea(t,v);
    }

    return v.y / UINT_MAX;
}

float test_trig( float2 v ) {
    for (int i = 0; i < ITERATIONS; i++) {
        v = trig(v).xx;
    }

    return v.y;
}

float test_wang( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = wang(s);
    }

    return s / UINT_MAX;
}

float test_xorshift128( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift128(v).xx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);
    uint s = seed(v);

    for (int i = 0; i < ITERATIONS; i++) {
        s = xorshift32(s);
    }

    return s / UINT_MAX;
}

float test_xxhash32( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xxhash32(v).xx;
    }

    return v.x / UINT_MAX;
}



uint test_hash3mul( uint v ) {
    for (int i = 0; i < ITERATIONS; i++) {
        v = hash3mul(v).z;
    }
    return v;
}

uint test_hash3add( uint v ) {
    for (int i = 0; i < ITERATIONS; i++) {
        v = hash3add(v).z;
    }
    return v;
}


// Single Dimension tests of Multi-Dimension hashes

// iqint2
float test_iqint2_x( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint2(v).xxx;
    }

    return v.x / UINT_MAX;
}

float test_iqint2_y( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint2(v).yyy;
    }

    return v.y / UINT_MAX;
}

float test_iqint2_z( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint2(v).zzz;
    }

    return v.z / UINT_MAX;
}

// pcg3d
float test_pcg3d_x( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d(v).xxx;
    }

    return v.x / UINT_MAX;
}

float test_pcg3d_y( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d(v).yyy;
    }

    return v.x / UINT_MAX;
}


float test_pcg3d_z( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d(v).zzz;
    }

    return v.x / UINT_MAX;
}

// pcg3d16
float test_pcg3d16_x( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d16(v).xxx;
    }

    return v.x / UINT16_MAX;
}

float test_pcg3d16_y( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d16(v).yyy;
    }

    return v.x / UINT16_MAX;
}


float test_pcg3d16_z( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0u);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg3d16(v).zzz;
    }

    return v.x / UINT16_MAX;
}

// pcg4d
float test_pcg4d_x( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg4d(v).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_pcg4d_y( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg4d(v).yyyy;
    }

    return v.x / UINT_MAX;
}

float test_pcg4d_z( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg4d(v).zzzz;
    }

    return v.x / UINT_MAX;
}

float test_pcg4d_w( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg4d(v).wwww;
    }

    return v.x / UINT_MAX;
}

// pcg2d
float test_pcg2d_x( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg2d(v).xx;
    }

    return v.x / UINT_MAX;
}

float test_pcg2d_y( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = pcg2d(v).yy;
    }

    return v.x / UINT_MAX;
}

// tea
float test_tea_x( uint t, float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = tea(t,v).xx;
    }

    return v.x / UINT_MAX;
}

float test_tea_y( uint t, float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = tea(t,v).yy;
    }

    return v.x / UINT_MAX;
}

// Seeded

float test_bbs_seed( float2 p ) {
    uint2 v = uint2(p * UINT16_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = bbs(seed(v)).xx;
    }

    return v.x / UINT16_MAX;
}

float test_city_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = city(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_esgtsa_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = esgtsa(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_iqint1_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint1(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_lcg_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        //v = lcg(seed(v)).xx;
        v = uint2(lcg(seed(v)), v.x);
    }

    return v.x / UINT_MAX;
}

float test_ranlim32_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = ranlim32(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_superfast_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = superfast(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_wang_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = wang(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32_seed( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift32(seed(v)).xx;
    }

    return v.x / UINT_MAX;
}

// Seeded3

float test_bbs_seed3( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = bbs(seed3(v)).xxx;
    }

    return v.x / UINT16_MAX;
}

float test_city_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = city(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_esgtsa_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        //v = uint3(esgtsa(seed3(v)), v.x, v.y);
        v = esgtsa(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_iqint1_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint1(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_lcg_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = lcg(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_ranlim32_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = ranlim32(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_superfast_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = superfast(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_wang_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = wang(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32_seed3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift32(seed3(v)).xxx;
    }

    return v.x / UINT_MAX;
}

// Nested

float test_bbs_nested( float2 p ) {
    uint2 v = uint2(p * UINT16_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = bbs(bbs(v.x) + v.y).xx;
    }

    return v.x / UINT16_MAX;
}

float test_city_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = city(city(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_esgtsa_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = esgtsa(esgtsa(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_iqint1_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint1(iqint1(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_lcg_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        //v = lcg(lcg(v.x) + v.y).xx;
        v = uint2(lcg(lcg(v.x) + v.y), v.x);
    }

    return v.x / UINT_MAX;
}

float test_ranlim32_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = ranlim32(ranlim32(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_superfast_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = superfast(superfast(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_wang_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = wang(wang(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32_nested( float2 p ) {
    uint2 v = uint2(p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift32(xorshift32(v.x) + v.y).xx;
    }

    return v.x / UINT_MAX;
}

// Nested 3
float test_bbs_nested3( float2 p ) {
    uint3 v = uint3(p * UINT16_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = bbs(bbs(bbs(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT16_MAX;
}

float test_city_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = city(city(city(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_esgtsa_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = esgtsa(esgtsa(esgtsa(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_iqint1_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint1(iqint1(iqint1(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_lcg_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = lcg(lcg(lcg(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_ranlim32_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = ranlim32(ranlim32(ranlim32(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_superfast_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = superfast(superfast(superfast(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_wang_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = wang(wang(wang(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32_nested3( float2 p ) {
    uint3 v = uint3(p * UINT_MAX, 0);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift32(xorshift32(xorshift32(v.x) + v.y) + v.z).xxx;
    }

    return v.x / UINT_MAX;
}

// Nested 4
float test_bbs_nested4( float2 p ) {
    uint4 v = uint4(p * UINT16_MAX, p * UINT16_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = bbs(bbs(bbs(bbs(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT16_MAX;
}

float test_city_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = city(city(city(city(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_esgtsa_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = esgtsa(esgtsa(esgtsa(esgtsa(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_iqint1_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = iqint1(iqint1(iqint1(iqint1(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_lcg_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        //v = lcg(lcg(lcg(lcg(v.x) + v.y) + v.z) + v.w).xxxx;
        v = uint4(lcg(lcg(lcg(lcg(v.x) + v.y) + v.z) + v.w), v.x, v.y, v.z);
    }

    return v.x / UINT_MAX;
}

float test_ranlim32_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = ranlim32(ranlim32(ranlim32(ranlim32(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_superfast_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = superfast(superfast(superfast(superfast(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_wang_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = wang(wang(wang(wang(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}

float test_xorshift32_nested4( float2 p ) {
    uint4 v = uint4(p * UINT_MAX, p * UINT_MAX);

    for (int i = 0; i < ITERATIONS; i++) {
        v = xorshift32(xorshift32(xorshift32(xorshift32(v.x) + v.y) + v.z) + v.w).xxxx;
    }

    return v.x / UINT_MAX;
}
